<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/ui/display-route.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/ui/display-route.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React from 'react';



/**
 *
 * Component to render users chosen route to canvas
 * @extends {React.Component}
 *
 */
class DisplayRoute extends React.Component {

    /**
     *
     * Pass props to super and initiate members
     * @param {Object} props - React props passed to component
     */
    constructor(props) {
        super(props);

        /**
         *
         * Amount of padding to allow around edges of canvas.
         * This is used to ensure that billboard circles are not cut off.
         */
        this.canvasPadding = 20;

        /**
         *
         * Most of the rendering here is handled outside of react.
         * This property will be updated whenever the component props
         * are changing. The renderRoute method will check each cycle
         * to see if the iteration parameter is same as last cycle.
         * If it isn't then it will stop rendering.
         */
        this.iteration = 0; 
    }

    /**
     *
     * React lifecycle method. Will be called if component is about
     * to update. This method is used to iterate the iteration parameter
     * and cancel any running renders.
     */
    componentWillUpdate() {
        this.iteration += 1;
    }

    /**
     *
     * React lifecycle method. If component recieves `route` props then
     * render canvas outside of react (see `renderRoute` method for details)
     */
    componentDidUpdate() {
        if(!this.props.route) return;

        this.renderRoute();
    }

    /**
     *
     * Convert passed coordinates to normalized pixel positions on page.
     *
     * @param {Number} pos    -           The x or y position from left or top side.
     *
     * @param {Array}  bounds -           The x or y bounds in the form [lower, upper]
     *                                    used to calculate the distance from furthest
     *                                    left/up to furthest right/down point.
     *
     * @param {Number} canvasSideLength - The length of the relevant (width or height) dimension

     */
    normaliseCoordinates(pos, bounds, canvasSideLength) {
        return (this.canvasPadding / 2) +                    // Push down/left by padding amount
               (pos - bounds[0]) / (bounds[1] - bounds[0]) * // Fraction that point is across bounds
               (canvasSideLength - this.canvasPadding);      // Multiplied by usable canvas width
    }


    /**
     *
     * Render route to canvas.
     * For longer routes there can be a lot of nodes so this handles rendering outside of react
     * for perforamnce reasons. Could perhaps be replaced with react-canvas or similar?
     */
    
    renderRoute() {
        // Save iteration at time of calling, will be checked each
        // cycle to make sure it hasn't changed.
        const iteration = this.iteration;

        // Save route to shorter var.
        const route = this.props.route;

        const xCoordRange = route.bounds.upper[0] - route.bounds.lower[0]; // The range of x values
        const yCoordRange = route.bounds.upper[1] - route.bounds.lower[1]; // The range of y values

        let canvasRatio = xCoordRange / yCoordRange;
        canvasRatio = canvasRatio &lt; 10 ? canvasRatio : 10; // Limit ratio to 10:1

        // Use multiple canvas layers so that they can be rendered separately
        const layers = {
            path : {
                canvas : this.refs.path,
                ctx : this.refs.path.getContext('2d')
            },
            billboards : {
                canvas : this.refs.billboards,
                ctx : this.refs.billboards.getContext('2d')
            }
        };

        // Calculate width/height based on canvas ratio
        const canvasWidth = 960;
        const canvasHeight = 960 / canvasRatio;

        // Set heights and widths of layers and contexts
        layers.path.canvas.width = canvasWidth;
        layers.path.canvas.height = canvasHeight;
        layers.billboards.canvas.width = canvasWidth;
        layers.billboards.canvas.height = canvasHeight;

        // Save x and y bounds separately for utility
        const xbounds = [route.bounds.lower[0], route.bounds.upper[0]];
        const ybounds = [route.bounds.lower[1], route.bounds.upper[1]];

        const optimized = !!route.optimizedPath;
        const pathToDraw = optimized ? route.optimizedPath : route.path;

        // @TODO identify start and end point?

        const rendersPerFrame = optimized ? 5 : 10; // Rendering once per frame is too slow, this speeds things up

        // Variables to be updated while looping through path
        let i = 0;                  // The current index
        let lastPos = [0,0];        // The x,y coords of last iteration
        let incrementalCount = {};  // An incremental count of photos taken of each billboard
        let rendersThisFrame = 0;   // Variable to be incremented for each render in a frame
        let distance = 0;           // Count the distance travelled over time
        let lastBillboardCount = 0; // Stop billboard count from jumping around

        const render = function() {
            // Cancel rendering if react has changed
            if(this.iteration !== iteration) return;

            const point = pathToDraw[i] === 'x' ? lastPos : pathToDraw[i];

            const x = this.normaliseCoordinates(point[0], xbounds, canvasWidth);
            const y = this.normaliseCoordinates(point[1], ybounds, canvasHeight);
            const lastx = this.normaliseCoordinates(lastPos[0], xbounds, canvasWidth);
            const lasty = this.normaliseCoordinates(lastPos[1], ybounds, canvasHeight);

            // Update incremental count object
            incrementalCount[point[0]] = incrementalCount[point[0]] || {};
            incrementalCount[point[0]][point[1]] = incrementalCount[point[0]][point[1]] || 0;
            incrementalCount[point[0]][point[1]] += 1;

            // If photo was taken then a billboard needs to be drawn
            if(pathToDraw[i] === 'x' || optimized) {
                layers.billboards.ctx.beginPath();
                layers.billboards.ctx.arc(x, y, 2, 0, Math.PI * 2, false);

                // Set fill style to hsla color range between green and red. Red spots indicate many
                // photos taken
                layers.billboards.ctx.fillStyle = 'hsla(' + (100 - (incrementalCount[point[0]][point[1]] / 10) * 80) +', 100%, 60%, 1)';
                layers.billboards.ctx.fill();
                layers.billboards.ctx.closePath();

                // Update billboard count
                let newBillboardCount = route.billboardMap[point[0]][point[1]] + 1;
                if(newBillboardCount > lastBillboardCount) {
                    this.refs.meta_billboards.textContent = newBillboardCount;
                    lastBillboardCount = newBillboardCount;
                }
            }
            // Otherwise, draw a path
            if(pathToDraw[i] !== 'x') {
                layers.path.ctx.beginPath();
                layers.path.ctx.moveTo(lastx, lasty);
                layers.path.ctx.lineTo(x,y);
                layers.path.ctx.strokeStyle = optimized ? 'rgba(255, 255, 255, 0.6)' : 'rgba(255, 255, 255, 0.2)';
                layers.path.ctx.stroke();
                layers.path.ctx.closePath();
                if(optimized) {
                    distance += Math.sqrt(Math.pow(point[0] - lastPos[0], 2) + Math.pow(point[1] - lastPos[1], 2)); // @TODO check against output from backend
                } else {
                    distance += 1;
                }

                // Draw text
                const xDirection = point[0] &lt; 0 ? 'West'  : 'East';
                const yDirection = point[1] &lt; 0 ? 'North' : 'South';

                this.refs.meta_distance.textContent = distance;
                this.refs.meta_position.textContent = Math.abs(point[0]) + 'km ' + xDirection + ' ' + 
                                                      Math.abs(point[1]) + 'km ' + yDirection + ' ';
            }

            lastPos = point;
            i += 1;

            // Stop rendering if at the end
            if(i &lt; pathToDraw.length) {
                // If we haven't made enough renders this frame then
                // don't request a new frame yet.
                if(rendersThisFrame &lt; rendersPerFrame) {
                    rendersThisFrame ++;
                    render();
                } else {
                    rendersThisFrame = 0;
                    requestAnimationFrame(render);
                }
            }
        }.bind(this);

        render();

    }


    /**
     *
     * Render component
     */ 
    render() {
        return (
            &lt;div className='displayRoute'>
                {this.props.route ? (
                    &lt;div className='displayRoute_layers'>
                        &lt;canvas ref='path'>&lt;/canvas>
                        &lt;canvas ref='billboards'>&lt;/canvas>
                        &lt;div className='displayRoute_meta'>
                            &lt;div className='displayRoute_meta_value'>
                                &lt;div className='displayRoute_meta_value_name'>
                                    Distance
                                &lt;/div>
                                &lt;div ref='meta_distance' className='displayRoute_meta_value_num'>
                                    
                                &lt;/div>
                                &lt;div className='displayRoute_meta_value_units'>
                                    KM
                                &lt;/div>
                            &lt;/div>

                            &lt;div className='displayRoute_meta_value'>
                                &lt;div className='displayRoute_meta_value_name'>
                                    Billboards Photographed
                                    &lt;small>(at least once)&lt;/small>
                                &lt;/div>
                                &lt;div ref='meta_billboards' className='displayRoute_meta_value_num displayRoute_meta_value_num-large'>
                                    
                                &lt;/div>
                            &lt;/div>

                            &lt;div className='displayRoute_meta_value'>
                                &lt;div className='displayRoute_meta_value_name'>
                                    Position from start
                                &lt;/div>
                                &lt;div ref='meta_position' className='displayRoute_meta_value_num'>
                                    
                                &lt;/div>
                            &lt;/div>
                        &lt;/div>
                    &lt;/div>
                ) : null}
            &lt;/div>
        );
    }
}

/**
 * Define proptypes for DisplayRoute component
 */
DisplayRoute.propTypes = {
    route : React.PropTypes.object
};


export default DisplayRoute;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-core_actions_index.html">core/actions/index</a></li><li><a href="module-core_reducers_index.html">core/reducers/index</a></li><li><a href="module-core_reducers_routing.html">core/reducers/routing</a></li></ul><h3>Classes</h3><ul><li><a href="App.html">App</a></li><li><a href="DisplayRoute.html">DisplayRoute</a></li><li><a href="Drone.html">Drone</a></li><li><a href="GetInput.html">GetInput</a></li><li><a href="PathParser.html">PathParser</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Jul 20 2016 00:02:48 GMT+1000 (AEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
